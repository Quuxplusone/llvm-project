// -*- C++ -*-
//===----------------------------------------------------------------------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_HIVE
#define _LIBCPP_HIVE

#include <__algorithm/equal.h>
#include <__algorithm/fill_n.h>
#include <__algorithm/lexicographical_compare_three_way.h>
#include <__algorithm/min.h>
#include <__algorithm/sort.h>
#include <__compare/synth_three_way.h>
#include <__assert> // all public C++ headers provide the assertion handler
#include <__bit/bit_cast.h>
#include <__concepts/assignable.h>
#include <__config>
#include <__functional/operations.h>
#include <__iterator/concepts.h>
#include <__iterator/distance.h>
#include <__iterator/iterator_traits.h>
#include <__iterator/move_iterator.h>
#include <__iterator/reverse_iterator.h>
#include <__memory/addressof.h>
#include <__memory/allocator.h>
#include <__memory/allocator_traits.h>
#include <__memory/pointer_traits.h>
#include <__memory/unique_ptr.h>
#include <__memory_resource/polymorphic_allocator.h>
#include <__ranges/concepts.h>
#include <__ranges/container_compatible_range.h>
#include <__ranges/from_range.h>
#include <__ranges/access.h>
#include <__ranges/size.h>
#include <__type_traits/conditional.h>
#include <__type_traits/enable_if.h>
#include <__type_traits/is_allocator.h>
#include <__type_traits/is_same.h>
#include <__type_traits/is_trivial.h>
#include <__type_traits/is_trivially_copyable.h>
#include <__type_traits/is_trivially_destructible.h>
#include <__type_traits/type_identity.h>
#include <__utility/exception_guard.h>
#include <__utility/exchange.h>
#include <__utility/forward.h>
#include <__utility/move.h>
#include <cstddef>
#include <limits>
#include <stdexcept>
#include <version>

// standard-mandated includes

// [hive.syn]
#include <compare>
#include <initializer_list>

#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)
#  pragma GCC system_header
#endif

#if _LIBCPP_STD_VER >= 20

_LIBCPP_PUSH_MACROS
#include <__undef_macros>

_LIBCPP_BEGIN_NAMESPACE_STD

// Copyright (c) 2022, Matthew Bentley (mattreecebentley@gmail.com) www.plflib.org
// Modified by Arthur O'Dwyer, 2022. Original source:
// https://github.com/mattreecebentley/plf_hive/blob/7b7763f/plf_hive.h

// zLib license (https://www.zlib.net/zlib_license.html):
// This software is provided 'as-is', without any express or implied
// warranty. In no event will the authors be held liable for any damages
// arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose,
// including commercial applications, and to alter it and redistribute it
// freely, subject to the following restrictions:
//
// 1. The origin of this software must not be misrepresented; you must not
//  claim that you wrote the original software. If you use this software
//  in a product, an acknowledgement in the product documentation would be
//  appreciated but is not required.
// 2. Altered source versions must be plainly marked as such, and must not be
//  misrepresented as being the original software.
// 3. This notice may not be removed or altered from any source distribution.

#ifndef PLF_HIVE_RANDOM_ACCESS_ITERATORS
 #define PLF_HIVE_RANDOM_ACCESS_ITERATORS 0
#endif

#if PLF_HIVE_RANDOM_ACCESS_ITERATORS
 #define PLF_HIVE_RELATIONAL_OPERATORS 1  // random access iterators require relational operators
#endif

#ifndef PLF_HIVE_RELATIONAL_OPERATORS
 #define PLF_HIVE_RELATIONAL_OPERATORS 1
#endif

#ifndef _LIBCPP_HIVE_DEBUGGING
 #define _LIBCPP_HIVE_DEBUGGING 0
#endif

#if _LIBCPP_HIVE_DEBUGGING
 #define _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD auto __guard = std::__make_exception_guard([&]() { __assert_invariants(); });
#else
 #define _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD /*nothing*/
#endif

template <class _Fp, class _Rp>
_LIBCPP_HIDE_FROM_ABI
inline void __hive_try_rollback(_Fp&& __task, _Rp&& rollback) {
  auto __guard = std::__make_exception_guard(rollback);
  __task();
  __guard.__complete();
}

template <class _Fp, class _Rp>
_LIBCPP_HIDE_FROM_ABI
inline void __hive_try_finally(_Fp&& __task, _Rp&& __finally) {
  auto __guard = std::__make_exception_guard(__finally);
  __task();
  // deliberately do not __guard.__complete(), so that __finally always runs
}

template <class _Tp, class _Allocator = std::allocator<_Tp>>
class hive {
  template <bool _IsConst> class __hive_iterator;
  friend class __hive_iterator<false>;
  friend class __hive_iterator<true>;

  using _SkipfieldType = unsigned short;
  using __alloc_traits = std::allocator_traits<_Allocator>;
  static constexpr _SkipfieldType _SkipMax = 65535;

public:
  using value_type = _Tp;
  using allocator_type = _Allocator;
  using size_type = typename __alloc_traits::size_type;
  using difference_type = typename __alloc_traits::difference_type;
  using pointer = typename __alloc_traits::pointer;
  using const_pointer = typename __alloc_traits::const_pointer;
  using reference = _Tp&;
  using const_reference = const _Tp&;
  using iterator = __hive_iterator<false>;
  using const_iterator = __hive_iterator<true>;
  using reverse_iterator = std::reverse_iterator<iterator>;
  using const_reverse_iterator = std::reverse_iterator<const_iterator>;

  static_assert(is_same<typename allocator_type::value_type, value_type>::value,
          "Allocator::value_type must be same type as value_type");

  static_assert(is_same<allocator_type, __rebind_alloc<__alloc_traits, value_type>>::value,
          "[allocator.requirements] states that rebinding an allocator to the same type should result in the "
          "original allocator");

private:
  _LIBCPP_HIDE_FROM_ABI
  auto __make_zero_argument_callback() {
    struct _Callback {
      void __construct_and_increment(allocator_type& __ea, _OveralignedEltPtr& __p) {
        __alloc_traits::construct(__ea, __p[0].__t());
        ++__p;
      }
    };
    return _Callback();
  }

  _LIBCPP_HIDE_FROM_ABI
  auto __make_value_callback(const value_type& __value) {
    struct _Callback {
      const value_type& __value_;
      void __construct_and_increment(allocator_type& __ea, _OveralignedEltPtr& __p) {
        __alloc_traits::construct(__ea, __p[0].__t(), __value_);
        ++__p;
      }
    };
    return _Callback{__value};
  }

  template <class _It>
  _LIBCPP_HIDE_FROM_ABI
  auto __make_itpair_callback(_It& __first) {
    struct _Callback {
      _It& __first_;
      void __construct_and_increment(allocator_type& __ea, _OveralignedEltPtr& __p) {
        __alloc_traits::construct(__ea, __p[0].__t(), *__first_);
        ++__p;
        ++__first_;
      }
    };
    return _Callback{__first};
  }

  template <class _Up> using _AllocOf = typename __alloc_traits::template rebind_alloc<_Up>;
  template <class _Up> using _PtrOf = typename std::allocator_traits<_AllocOf<_Up>>::pointer;

  struct _OveralignedElt {
    union {
      char __dummy_;
      struct {
        _SkipfieldType nextlink_;
        _SkipfieldType prevlink_;
      };
      _Tp __t_;
    };
    _LIBCPP_HIDE_FROM_ABI _Tp* __t() { return std::addressof(__t_); }
  };

  struct group;
  using _OveralignedEltPtr = _PtrOf<_OveralignedElt>;
  using _GroupPtr = _PtrOf<group>;
  using _SkipfieldPtr = _PtrOf<_SkipfieldType>;

  struct group {
    _OveralignedEltPtr last_endpoint;
      // The address which is one-past the highest cell number that's been used so far in this group - does not change via erasure
      // but may change via insertion/emplacement/assignment (if no previously-erased locations are available to insert to).
      // This variable is necessary because an iterator cannot access the hive's __end_. It is probably the most-used variable
      // in general hive usage (being heavily used in operator ++, --), so is first in struct. If all cells in the group have
      // been inserted into at some point, it will be == reinterpret_cast<_OveralignedEltPtr>(skipfield).
    _GroupPtr __next_group = nullptr;
    _GroupPtr __prev_group = nullptr;
    _SkipfieldType free_list_head = _SkipMax;
      // The index of the last erased element in the group. The last erased element will, in turn, contain
      // the number of the index of the next erased element, and so on. If this is == maximum _SkipfieldType value
      // then free_list is empty ie. no erasures have occurred in the group.
    _SkipfieldType capacity;
    _SkipfieldType size = 0;
      // The total number of active elements in group - changes with insert and erase commands - used to check for empty group in erase function,
      // as an indication to remove the group. Also used in combination with capacity to check if group is full.
    _GroupPtr next_erasure_ = nullptr;
      // The next group in the singly-linked list of groups with erasures ie. with active erased-element free lists. nullptr if no next group.
#if PLF_HIVE_RELATIONAL_OPERATORS
    size_type groupno_ = 0;
      // Used for comparison (> < >= <= <=>) iterator operators (used by distance function and user).
#endif

#if PLF_HIVE_RELATIONAL_OPERATORS
    inline size_t __group_number() const { return groupno_; }
    inline void __set_group_number(size_type x) { groupno_ = x; }
#else
    inline size_t __group_number() const { return 42; }
    inline void __set_group_number(size_type) { }
#endif

#if _LIBCPP_HIVE_DEBUGGING
    _LIBCPP_HIDE_FROM_ABI
    void __debug_dump() {
      printf(
        "  group #%zu [%zu/%zu used] (last_endpoint=%p, elts=%p, skipfield=%p, freelist=%zu, erasenext=%p)",
        __group_number(), size_t(size), size_t(capacity),
        (void*)last_endpoint, (void*)__addr_of_element(0), (void*)__addr_of_skipfield(0), size_t(free_list_head), (void*)next_erasure_
      );
      if (__next_group) {
        printf(" next: #%zu", __next_group->__group_number());
      } else {
        printf(" next: null");
      }
      if (__prev_group) {
        printf(" prev: #%zu\n", __prev_group->__group_number());
      } else {
        printf(" prev: null\n");
      }
      printf("  skipfield[] =");
      for (int i = 0; i < capacity; ++i) {
        if (__skipfield(i) == 0) {
          printf(" _");
        } else {
          printf(" %d", int(__skipfield(i)));
        }
      }
      if (__skipfield(capacity) == 0) {
        printf(" [_]\n");
      } else {
        printf(" [%d]\n", int(__skipfield(capacity)));
      }
    }
#endif // _LIBCPP_HIVE_DEBUGGING

    _LIBCPP_HIDE_FROM_ABI
    explicit group(_SkipfieldType cap)
      : last_endpoint(__addr_of_element(0)), capacity(cap)
    {
      std::fill_n(__addr_of_skipfield(0), cap + 1, _SkipfieldType());
    }

    _LIBCPP_HIDE_FROM_ABI
    bool __is_packed() const {
      return free_list_head == _SkipMax;
    }

    _LIBCPP_HIDE_FROM_ABI _OveralignedEltPtr __addr_of_element(size_type __n) { return _GroupAllocHelper::__elements(this) + __n; }
    _LIBCPP_HIDE_FROM_ABI _OveralignedElt& element(size_type __n) { return _GroupAllocHelper::__elements(this)[__n]; }
    _LIBCPP_HIDE_FROM_ABI _OveralignedEltPtr __end_of_elements() { return _GroupAllocHelper::__elements(this) + capacity; }

    _LIBCPP_HIDE_FROM_ABI _SkipfieldPtr __addr_of_skipfield(size_type __n) { return _GroupAllocHelper::__skipfield(this) + __n; }
    _LIBCPP_HIDE_FROM_ABI _SkipfieldType& __skipfield(size_type __n) { return _GroupAllocHelper::__skipfield(this)[__n]; }

    _LIBCPP_HIDE_FROM_ABI _SkipfieldType __index_of_last_endpoint() { return last_endpoint - __addr_of_element(0); }

    _LIBCPP_HIDE_FROM_ABI
    void reset(_SkipfieldType increment, _GroupPtr next, _GroupPtr prev, size_type groupno) {
      last_endpoint = __addr_of_element(increment);
      __next_group = next;
      free_list_head = _SkipMax;
      __prev_group = prev;
      size = increment;
      next_erasure_ = nullptr;
      __set_group_number(groupno);
      std::fill_n(__addr_of_skipfield(0), capacity, _SkipfieldType());
    }
  };

  template <bool _IsConst>
  class __hive_iterator {
  public:
    using value_type = typename hive::value_type;
    using difference_type = typename hive::difference_type;
    using pointer = std::conditional_t<_IsConst, typename hive::const_pointer, typename hive::pointer>;
    using reference = std::conditional_t<_IsConst, typename hive::const_reference, typename hive::reference>;
#if PLF_HIVE_RANDOM_ACCESS_ITERATORS
    using iterator_category = std::random_access_iterator_tag;
#else
    using iterator_category = std::bidirectional_iterator_tag;
#endif

    _LIBCPP_HIDE_FROM_ABI explicit __hive_iterator() = default;
    _LIBCPP_HIDE_FROM_ABI __hive_iterator(__hive_iterator&&) = default;
    _LIBCPP_HIDE_FROM_ABI __hive_iterator(const __hive_iterator&) = default;
    _LIBCPP_HIDE_FROM_ABI __hive_iterator& operator=(__hive_iterator&&) = default;
    _LIBCPP_HIDE_FROM_ABI __hive_iterator& operator=(const __hive_iterator&) = default;

    template <bool _IsConst_ = _IsConst, class = std::enable_if_t<_IsConst_>>
    _LIBCPP_HIDE_FROM_ABI
    __hive_iterator(const __hive_iterator<false>& rhs)
      : group_(rhs.group_), idx_(rhs.idx_)
    {}

    template <bool _IsConst_ = _IsConst, class = std::enable_if_t<_IsConst_>>
    _LIBCPP_HIDE_FROM_ABI
    __hive_iterator(__hive_iterator<false>&& rhs)
      : group_(std::move(rhs.group_)), idx_(std::move(rhs.idx_))
    {}

    _LIBCPP_HIDE_FROM_ABI
    reference operator*() const noexcept {
      return *group_->element(idx_).__t();
    }

    _LIBCPP_HIDE_FROM_ABI
    pointer operator->() const noexcept {
      return pointer_traits<pointer>::pointer_to(*group_->element(idx_).__t());
    }

    _LIBCPP_HIDE_FROM_ABI
    __hive_iterator& operator++() {
      _LIBCPP_ASSERT(group_ != nullptr, "");
      auto __inc = 1 + group_->__skipfield(idx_ + 1);
      idx_ += __inc;
      if (idx_ == group_->__index_of_last_endpoint() && group_->__next_group != nullptr) {
        group_ = group_->__next_group;
        idx_ = group_->__skipfield(0);
      }
      return *this;
    }

    _LIBCPP_HIDE_FROM_ABI
    __hive_iterator& operator--() {
      _LIBCPP_ASSERT(group_ != nullptr, "");
      if (idx_ != 0) {
        _SkipfieldType __dec = group_->__skipfield(idx_ - 1);
        if (__dec != idx_) {
           idx_ -= __dec + 1;
           return *this;
        }
      }
      group_ = group_->__prev_group;
      idx_ = group_->capacity - 1 - group_->__skipfield(group_->capacity - 1);
      return *this;
    }

    _LIBCPP_HIDE_FROM_ABI __hive_iterator operator++(int) { auto __copy = *this; ++*this; return __copy; }
    _LIBCPP_HIDE_FROM_ABI __hive_iterator operator--(int) { auto __copy = *this; --*this; return __copy; }

    _LIBCPP_HIDE_FROM_ABI
    void __advance(difference_type n) {
      if (n > 0) {
        __advance_forward(n);
      } else if (n < 0) {
        __advance_backward(n);
      }
    }

    _LIBCPP_HIDE_FROM_ABI
    __hive_iterator __next(difference_type n) const {
      auto copy = *this;
      copy.__advance(n);
      return copy;
    }

    _LIBCPP_HIDE_FROM_ABI
    __hive_iterator __prev(difference_type n) const {
      auto copy = *this;
      copy.__advance(-n);
      return copy;
    }

    _LIBCPP_HIDE_FROM_ABI
    difference_type __distance(__hive_iterator last) const {
#if PLF_HIVE_RELATIONAL_OPERATORS
      if (last < *this) {
        return -last.__distance_forward(*this);
      }
#endif
      return __distance_forward(last);
    }

    _LIBCPP_HIDE_FROM_ABI
    friend bool operator==(const __hive_iterator&, const __hive_iterator&) = default;

#if PLF_HIVE_RELATIONAL_OPERATORS
    _LIBCPP_HIDE_FROM_ABI
    friend std::strong_ordering operator<=>(const __hive_iterator& a, const __hive_iterator& b) {
      return a.group_ == b.group_ ?
        a.idx_ <=> b.idx_ :
        a.group_->groupno_ <=> b.group_->groupno_;
    }
#endif

    _LIBCPP_HIDE_FROM_ABI
    friend void swap(__hive_iterator& a, __hive_iterator& b) noexcept {
      using std::swap;
      swap(a.group_, b.group_);
      swap(a.idx_, b.idx_);
    }

#if PLF_HIVE_RANDOM_ACCESS_ITERATORS
    friend __hive_iterator& operator+=(__hive_iterator& a, difference_type n) { a.__advance(n); return a; }
    friend __hive_iterator& operator-=(__hive_iterator& a, difference_type n) { a.__advance(-n); return a; }
    friend __hive_iterator operator+(const __hive_iterator& a, difference_type n) { return a.__next(n); }
    friend __hive_iterator operator+(difference_type n, const __hive_iterator& a) { return a.__next(n); }
    friend __hive_iterator operator-(const __hive_iterator& a, difference_type n) { return a.__prev(n); }
    friend difference_type operator-(const __hive_iterator& a, const __hive_iterator& b) { return b.__distance(a); }
    reference operator[](difference_type n) const { return *__next(n); }
#endif

  private:
    template <bool _IsConst_ = _IsConst, class = std::enable_if_t<_IsConst_>>
    _LIBCPP_HIDE_FROM_ABI
    __hive_iterator<false> __unconst() const {
      __hive_iterator<false> __it;
      __it.group_ = group_;
      __it.idx_ = idx_;
      return __it;
    }

    _LIBCPP_HIDE_FROM_ABI
    explicit __hive_iterator(_GroupPtr __g, size_t __idx)
      : group_(__g), idx_(__idx) {}

#if _LIBCPP_HIVE_DEBUGGING
    _LIBCPP_HIDE_FROM_ABI
    void __debug_dump() const {
      printf("iterator(");
      if (group_) printf("#%zu", group_->__group_number());
      else printf("null");
      printf(", %zu)\n", size_t(idx_));
    }
#endif // _LIBCPP_HIVE_DEBUGGING

    _LIBCPP_HIDE_FROM_ABI
    void __advance_forward(difference_type n) {
      _LIBCPP_ASSERT(n > 0, "");
      _LIBCPP_ASSERT(group_ != nullptr, "");

      if (idx_ != group_->__skipfield(0)) {
        _SkipfieldType endpoint = group_->__index_of_last_endpoint();
        while (true) {
          ++idx_;
          idx_ += group_->__skipfield(idx_);
          --n;
          if (idx_ == endpoint) {
            break;
          } else if (n == 0) {
            return;
          }
        }
        if (group_->__next_group == nullptr) {
          return;
        }
        group_ = group_->__next_group;
        if (n == 0) {
          idx_ = group_->__skipfield(0);
          return;
        }
      }

      while (static_cast<difference_type>(group_->size) <= n) {
        if (group_->__next_group == nullptr) {
          idx_ = group_->__index_of_last_endpoint();
          return;
        } else {
          n -= group_->size;
          group_ = group_->__next_group;
          if (n == 0) {
            idx_ = group_->__skipfield(0);
            return;
          }
        }
      }

      if (group_->__is_packed()) {
        idx_ = n;
      } else {
        idx_ = group_->__skipfield(0);
        do {
          idx_ += 1 + group_->__skipfield(idx_ + 1);
        } while (--n != 0);
      }
    }

    _LIBCPP_HIDE_FROM_ABI
    void __advance_backward(difference_type n) {
      _LIBCPP_ASSERT(n < 0, "");
      _LIBCPP_ASSERT(!(idx_ == group_->__skipfield(0) && group_->__prev_group == nullptr), "");

      if (idx_ != group_->__index_of_last_endpoint()) {
        if (group_->__is_packed()) {
          difference_type __distance_from_beginning = -static_cast<difference_type>(idx_);
          if (n >= __distance_from_beginning) {
            idx_ += n;
            return;
          } else if (group_->__prev_group == nullptr) {
            idx_ = 0;
            return;
          } else {
            n -= __distance_from_beginning;
          }
        } else {
          _SkipfieldType beginning_point = group_->__skipfield(0);
          while (idx_ != beginning_point) {
            --idx_;
            idx_ -= group_->__skipfield(idx_);
            if (++n == 0) {
              return;
            }
          }
          if (group_->__prev_group == nullptr) {
            idx_ = group_->__skipfield(0);
            return;
          }
        }
        group_ = group_->__prev_group;
      }

      while (n < -static_cast<difference_type>(group_->size)) {
        if (group_->__prev_group == nullptr) {
          idx_ = group_->__skipfield(0);
          return;
        }
        n += group_->size;
        group_ = group_->__prev_group;
      }

      if (n == -static_cast<difference_type>(group_->size)) {
        idx_ = group_->__skipfield(0);
      } else if (group_->__is_packed()) {
        idx_ = group_->size + n;
      } else {
        idx_ = group_->__index_of_last_endpoint();
        do {
          --idx_;
          idx_ -= group_->__skipfield(idx_);
        } while (++n != 0);
      }
    }

    _LIBCPP_HIDE_FROM_ABI difference_type __index_in_group() const { return idx_; }

    _LIBCPP_HIDE_FROM_ABI
    difference_type __distance_from_start_of_group() const {
      _LIBCPP_ASSERT(group_ != nullptr, "");
      if (group_->__is_packed() || idx_ == 0) {
        return idx_;
      } else {
        difference_type __count = 0;
        _SkipfieldType endpoint = group_->__index_of_last_endpoint();
        for (_SkipfieldType i = idx_; i != endpoint; ++__count) {
          ++i;
          i += group_->__skipfield(i);
        }
        return group_->size - __count;
      }
    }

    _LIBCPP_HIDE_FROM_ABI
    difference_type __distance_from_end_of_group() const {
      _LIBCPP_ASSERT(group_ != nullptr, "");
      if (group_->__is_packed() || idx_ == 0) {
        return group_->size - idx_;
      } else {
        difference_type __count = 0;
        _SkipfieldType endpoint = group_->__index_of_last_endpoint();
        for (_SkipfieldType i = idx_; i != endpoint; ++__count) {
          ++i;
          i += group_->__skipfield(i);
        }
        return __count;
      }
    }

    _LIBCPP_HIDE_FROM_ABI
    difference_type __distance_forward(__hive_iterator last) const {
      if (last.group_ != group_) {
        difference_type __count = last.__distance_from_start_of_group();
        for (_GroupPtr g = last.group_->__prev_group; g != group_; g = g->__prev_group) {
          __count += g->size;
        }
        return __count + this->__distance_from_end_of_group();
      } else if (idx_ == last.idx_) {
        return 0;
      } else if (group_->__is_packed()) {
        return last.idx_ - idx_;
      } else {
        difference_type __count = 0;
        while (last.idx_ != idx_) {
          --last.idx_;
          last.idx_ -= last.group_->__skipfield(last.idx_);
          ++__count;
        }
        return __count;
      }
    }

    friend class hive;

    _GroupPtr group_ = _GroupPtr();
    _SkipfieldType idx_ = 0;
  }; // class __hive_iterator

public:
  _LIBCPP_HIDE_FROM_ABI
  void __assert_invariants() const {
#if _LIBCPP_HIVE_DEBUGGING
    _LIBCPP_DEBUG_ASSERT(size_ <= __capacity_, "");
    if (size_ == 0) {
      _LIBCPP_DEBUG_ASSERT(__begin_ == __end_, "");
      if (__capacity_ == 0) {  // TODO FIXME BUG HACK: this should be `if (true)`
        _LIBCPP_DEBUG_ASSERT(__begin_.group_ == nullptr, "");
        _LIBCPP_DEBUG_ASSERT(__begin_.idx_ == 0, "");
        _LIBCPP_DEBUG_ASSERT(__end_.group_ == nullptr, "");
        _LIBCPP_DEBUG_ASSERT(__end_.idx_ == 0, "");
      }
      _LIBCPP_DEBUG_ASSERT(__groups_with_erasures_ == nullptr, "");
      if (__capacity_ == 0) {
        _LIBCPP_DEBUG_ASSERT(__unused_groups_ == nullptr, "");
      } else {
        if (__begin_.group_ == nullptr) {
          _LIBCPP_DEBUG_ASSERT(__unused_groups_ != nullptr, "");  // the capacity must be somewhere
        }
      }
    } else {
      _LIBCPP_DEBUG_ASSERT(__begin_.group_ != nullptr, "");
      _LIBCPP_DEBUG_ASSERT(__begin_.group_->__prev_group == nullptr, "");
      _LIBCPP_DEBUG_ASSERT(__end_.group_ != nullptr, "");
      _LIBCPP_DEBUG_ASSERT(__end_.idx_ == __end_.group_->__index_of_last_endpoint(), "");
      _LIBCPP_DEBUG_ASSERT(__end_.group_->__next_group == nullptr, "");
      _LIBCPP_DEBUG_ASSERT(__begin_ != __end_, "");
      if (__capacity_ == size_) {
        _LIBCPP_DEBUG_ASSERT(__unused_groups_ == nullptr, "");
      }
    }
    size_type total_size = 0;
    size_type total_cap = 0;
    for (_GroupPtr g = __begin_.group_; g != nullptr; g = g->__next_group) {
      // _LIBCPP_DEBUG_ASSERT(g->size >= 1, ""); // TODO FIXME BUG HACK
      _LIBCPP_DEBUG_ASSERT(g->size <= g->capacity, "");
      total_size += g->size;
      total_cap += g->capacity;
      if (g->__is_packed()) {
        _LIBCPP_DEBUG_ASSERT(g->last_endpoint == g->__addr_of_element(g->size), "");
      } else {
        _LIBCPP_DEBUG_ASSERT(g->size < g->capacity, "");
        _LIBCPP_DEBUG_ASSERT(g->last_endpoint > g->__addr_of_element(g->size), "");
        _LIBCPP_DEBUG_ASSERT(g->__skipfield(g->free_list_head) != 0, "");
      }
      if (g->last_endpoint != g->__end_of_elements()) {
        _LIBCPP_DEBUG_ASSERT(g == __end_.group_, "");
        _LIBCPP_DEBUG_ASSERT(g->__next_group == nullptr, "");
      }
      _LIBCPP_DEBUG_ASSERT(g->__skipfield(g->last_endpoint - g->__addr_of_element(0)) == 0, "");
      if (g->size != g->capacity && g->__next_group != nullptr) {
        _LIBCPP_DEBUG_ASSERT(!g->__is_packed(), "");
      }
#if PLF_HIVE_RELATIONAL_OPERATORS
      if (g->__next_group != nullptr) {
        _LIBCPP_DEBUG_ASSERT(g->__group_number() < g->__next_group->__group_number(), "");
      }
#endif
      _SkipfieldType total_skipped = 0;
      for (_SkipfieldType sb = g->free_list_head; sb != _SkipMax; sb = g->element(sb).nextlink_) {
        _SkipfieldType skipblock_length = g->__skipfield(sb);
        _LIBCPP_DEBUG_ASSERT(skipblock_length != 0, "");
        _LIBCPP_DEBUG_ASSERT(g->__skipfield(sb + skipblock_length - 1) == skipblock_length, "");
        total_skipped += skipblock_length;
        if (sb == g->free_list_head) {
          _LIBCPP_DEBUG_ASSERT(g->element(sb).prevlink_ == _SkipMax, "");
        }
        if (g->element(sb).nextlink_ != _SkipMax) {
          _LIBCPP_DEBUG_ASSERT(g->element(g->element(sb).nextlink_).prevlink_ == sb, "");
        }
      }
      if (g == __end_.group_) {
        _LIBCPP_DEBUG_ASSERT(g->capacity == g->size + total_skipped + (g->__end_of_elements() - g->last_endpoint), "");
      } else {
        _LIBCPP_DEBUG_ASSERT(g->capacity == g->size + total_skipped, "");
      }
    }
    _LIBCPP_DEBUG_ASSERT(total_size == size_, "");
    _LIBCPP_DEBUG_ASSERT((__unused_groups_ != nullptr) == (__unused_groups_tail_ != nullptr), "");
    for (_GroupPtr g = __unused_groups_; g != nullptr; g = g->__next_group) {
      total_cap += g->capacity;
      if (g->__next_group == nullptr) {
        _LIBCPP_DEBUG_ASSERT(__unused_groups_tail_ == g, "");
      }
    }
    _LIBCPP_DEBUG_ASSERT(total_cap == __capacity_, "");
    if (size_ == __capacity_) {
      _LIBCPP_DEBUG_ASSERT(__groups_with_erasures_ == nullptr, "");
      _LIBCPP_DEBUG_ASSERT(__unused_groups_ == nullptr, "");
    } else {
      size_type space_in_last_group = __end_.group_ != nullptr ? (__end_.group_->capacity - __end_.idx_) : 0;
      _LIBCPP_DEBUG_ASSERT(size_ + space_in_last_group == __capacity_ || __groups_with_erasures_ != nullptr || __unused_groups_ != nullptr, "");
    }
    for (_GroupPtr g = __groups_with_erasures_; g != nullptr; g = g->next_erasure_) {
      _LIBCPP_DEBUG_ASSERT(g->size < g->capacity, "");
    }
#endif // _LIBCPP_HIVE_DEBUGGING
  }

#if _LIBCPP_HIVE_DEBUGGING
  _LIBCPP_HIDE_FROM_ABI
  void __debug_dump() const {
    printf(
      "hive [%zu/%zu used] (erase=%p, unused=%p, mincap=%zu, maxcap=%zu)\n",
      size_t(size_), size_t(__capacity_),
      __groups_with_erasures_, __unused_groups_,
      size_t(__impl_min_block_size()), size_t(__impl_max_block_size())
    );
    printf("  begin="); __begin_.__debug_dump();
    size_t total = 0;
    group *prev = nullptr;
    for (auto *g = __begin_.group_; g != nullptr; g = g->__next_group) {
      g->__debug_dump();
      total += g->size;
      _LIBCPP_DEBUG_ASSERT(g->__prev_group == prev, "");
      prev = g;
    }
    _LIBCPP_DEBUG_ASSERT(total == size_, "");
    printf("  end="); __end_.__debug_dump();
    if (__end_.group_) {
      _LIBCPP_DEBUG_ASSERT(__end_.group_->__next_group == nullptr, "");
    }
    printf("UNUSED GROUPS:\n");
    for (auto *g = __unused_groups_; g != nullptr; g = g->__next_group) {
      g->__debug_dump();
      _LIBCPP_DEBUG_ASSERT(g != __begin_.group_, "");
      _LIBCPP_DEBUG_ASSERT(g != __end_.group_, "");
    }
    printf("GROUPS WITH ERASURES:");
    for (auto *g = __groups_with_erasures_; g != nullptr; g = g->next_erasure_) {
      printf(" %zu", g->__group_number());
    }
    printf("\n");
  }
#endif // _LIBCPP_HIVE_DEBUGGING

public:
  _LIBCPP_HIDE_FROM_ABI hive() = default;

  _LIBCPP_HIDE_FROM_ABI
  explicit hive(const allocator_type& __alloc)
    : __allocator_(__alloc) {}

  _LIBCPP_HIDE_FROM_ABI
  hive(const hive& __h)
    : hive(__h, __alloc_traits::select_on_container_copy_construction(__h.__allocator_)) {}

  _LIBCPP_HIDE_FROM_ABI
  hive(const hive& __h, const type_identity_t<allocator_type>& __alloc) :
    __allocator_(__alloc)
  {
    reserve(__h.size());
    __range_assign_impl(__h.begin(), __h.end());
  }

  _LIBCPP_HIDE_FROM_ABI
  hive(hive&& __h) noexcept :
    __end_(std::move(__h.__end_)),
    __begin_(std::move(__h.__begin_)),
    __groups_with_erasures_(std::move(__h.__groups_with_erasures_)),
    __unused_groups_(std::move(__h.__unused_groups_)),
    size_(__h.size_),
    __capacity_(__h.__capacity_),
    __allocator_(__h.get_allocator())
  {
    __h.__blank();
  }

  _LIBCPP_HIDE_FROM_ABI
  hive(hive&& __h, const type_identity_t<allocator_type>& __alloc) : hive(__alloc)
  {
    bool __should_use_source_allocator = (
      __alloc_traits::is_always_equal::value ||
      __alloc == __h.get_allocator()
    );
    if (__should_use_source_allocator) {
      *this = std::move(__h);
    } else {
      reserve(__h.size());
      __range_assign_impl(std::make_move_iterator(__h.begin()), std::make_move_iterator(__h.end()));
    }
  }

  template <class = __enable_if_t<__is_allocator<_Allocator>::value>>
  _LIBCPP_HIDE_FROM_ABI
  hive(size_type __n, const value_type& __value, const allocator_type& __alloc = allocator_type())
    : __allocator_(__alloc)
  {
    assign(__n, __value);
  }

  _LIBCPP_HIDE_FROM_ABI
  explicit hive(size_type __n) {
    __callback_insert_impl(__n, __make_zero_argument_callback());
  }

  _LIBCPP_HIDE_FROM_ABI
  hive(size_type __n, const allocator_type& __alloc) :
    __allocator_(__alloc)
  {
    __callback_insert_impl(__n, __make_zero_argument_callback());
  }

  template <class _InputIterator>
    requires __is_cpp17_input_iterator<_InputIterator>::value &&
         __is_allocator<allocator_type>::value
  _LIBCPP_HIDE_FROM_ABI
  hive(_InputIterator __first, _InputIterator __last, const allocator_type& __alloc = allocator_type()) :
    __allocator_(__alloc)
  {
    assign(__first, __last);
  }

  _LIBCPP_HIDE_FROM_ABI
  hive(std::initializer_list<_Tp> __il, const allocator_type& __alloc = allocator_type()) :
    __allocator_(__alloc)
  {
    assign(__il.begin(), __il.end());
  }

#if _LIBCPP_STD_VER >= 23
  template <__container_compatible_range<_Tp> _Rp>
  _LIBCPP_HIDE_FROM_ABI
  hive(std::from_range_t, _Rp&& __r)
  {
    assign_range(std::forward<_Rp>(__r));
  }

  template <__container_compatible_range<_Tp> _Rp>
  _LIBCPP_HIDE_FROM_ABI
  hive(std::from_range_t, _Rp&& __r, const allocator_type& __alloc) :
    __allocator_(__alloc)
  {
    assign_range(std::forward<_Rp>(__r));
  }
#endif

  _LIBCPP_HIDE_FROM_ABI
  ~hive() {
    __assert_invariants();
    __destroy_all_data();
  }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI
  iterator emplace(_Args&&... __args) {
    if (__trailing_capacity() != 0) {
      return __unchecked_emplace_at_end(std::forward<_Args>(__args)...);
    } else if (__groups_with_erasures_ != nullptr) {
      return __unchecked_emplace_in_hole(std::forward<_Args>(__args)...);
    } else {
      return __unchecked_emplace_in_new_group_at_end(std::forward<_Args>(__args)...);
    }
  }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI
  reference emplace_back(_Args&&... __args) {
    if (__trailing_capacity() != 0) {
      return *__unchecked_emplace_at_end(std::forward<_Args>(__args)...);
    } else {
      return *__unchecked_emplace_in_new_group_at_end(std::forward<_Args>(__args)...);
    }
  }

  _LIBCPP_HIDE_FROM_ABI void push_back(const value_type& __value) { emplace_back(__value); }
  _LIBCPP_HIDE_FROM_ABI void push_back(value_type&& __value) { emplace_back(std::move(__value)); }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI iterator emplace_hint(const_iterator, _Args&&... __args) { return emplace(std::forward<_Args>(__args)...); }

  _LIBCPP_HIDE_FROM_ABI iterator insert(const value_type& __value) { return emplace(__value); }
  _LIBCPP_HIDE_FROM_ABI iterator insert(value_type&& __value) { return emplace(std::move(__value)); }

  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator, const value_type& __value) { return emplace(__value); }
  _LIBCPP_HIDE_FROM_ABI iterator insert(const_iterator, value_type&& __value) { return emplace(std::move(__value)); }

  _LIBCPP_HIDE_FROM_ABI
  void insert(size_type __n, const value_type& __value) {
    if (__n == 0) {
      // do nothing
    } else if (__n == 1) {
      insert(__value);
    } else {
      __callback_insert_impl(__n, __make_value_callback(__value));
    }
  }

  template <class _InputIterator>
    requires __is_cpp17_input_iterator<_InputIterator>::value
  _LIBCPP_HIDE_FROM_ABI
  void insert(_InputIterator __first, _InputIterator __last) {
    __range_insert_impl(__first, __last);
  }

#if _LIBCPP_STD_VER >= 23
  template <__container_compatible_range<_Tp> _Rp>
  _LIBCPP_HIDE_FROM_ABI
  void insert_range(_Rp&& __r) {
    if constexpr (std::ranges::sized_range<_Rp&>) {
      reserve(size() + std::ranges::size(__r));
    }
    __range_insert_impl(std::ranges::begin(__r), std::ranges::end(__r));
  }
#endif

  _LIBCPP_HIDE_FROM_ABI
  void insert(std::initializer_list<_Tp> __il) {
    __range_insert_impl(__il.begin(), __il.end());
  }

  _LIBCPP_HIDE_FROM_ABI
  iterator erase(const_iterator it) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    _LIBCPP_ASSERT(size_ != 0, "");
    _LIBCPP_ASSERT(it.group_ != nullptr, "");
    _LIBCPP_ASSERT(it.idx_ != it.group_->__index_of_last_endpoint(), "");
    _LIBCPP_ASSERT(it.group_->__skipfield(it.idx_) == 0, "");

    if constexpr (!std::is_trivially_destructible<_Tp>::value) {
      allocator_type ea = get_allocator();
      __alloc_traits::destroy(ea, std::addressof(*it));
    }

    _GroupPtr g = it.group_;

    --size_;
    --(g->size);

    if (g->size != 0) {
      const char prev_skipfield = (g->__skipfield(it.idx_ - (it.idx_ != 0)) != 0);
      const char after_skipfield = (g->__skipfield(it.idx_ + 1) != 0);
      _SkipfieldType update_value = 1;

      if (!(prev_skipfield | after_skipfield)) {
        g->__skipfield(it.idx_) = 1;
        if (g->__is_packed()) {
          g->next_erasure_ = std::exchange(__groups_with_erasures_, g);
        } else {
          g->element(g->free_list_head).prevlink_ = it.idx_;
        }
        g->element(it.idx_).nextlink_ = g->free_list_head;
        g->element(it.idx_).prevlink_ = _SkipMax;
        g->free_list_head = it.idx_;
      } else if (prev_skipfield & (!after_skipfield)) {
        // previous erased consecutive elements, none following
        _SkipfieldType new_skipblock_length = g->__skipfield(it.idx_ - 1) + 1;
        g->__skipfield(it.idx_) = new_skipblock_length;
        g->__skipfield(it.idx_ - (new_skipblock_length - 1)) = new_skipblock_length;
      } else if ((!prev_skipfield) & after_skipfield) {
        // following erased consecutive elements, none preceding
        _SkipfieldType new_skipblock_length = g->__skipfield(it.idx_ + 1) + 1;
        g->__skipfield(it.idx_) = new_skipblock_length;
        g->__skipfield(it.idx_ + (new_skipblock_length - 1)) = new_skipblock_length;

        const _SkipfieldType following_previous = g->element(it.idx_ + 1).nextlink_;
        const _SkipfieldType following_next = g->element(it.idx_ + 1).prevlink_;
        g->element(it.idx_).nextlink_ = following_previous;
        g->element(it.idx_).prevlink_ = following_next;

        const _SkipfieldType index = static_cast<_SkipfieldType>(it.__index_in_group());

        if (following_previous != _SkipMax) {
          g->element(following_previous).prevlink_ = index;
        }

        if (following_next != _SkipMax) {
          g->element(following_next).nextlink_ = index;
        } else {
          g->free_list_head = index;
        }
        update_value = new_skipblock_length;
      } else {
        // both preceding and following consecutive erased elements - erased element is between two skipblocks
        _SkipfieldType preceding_value = g->__skipfield(it.idx_ - 1);
        _SkipfieldType following_value = g->__skipfield(it.idx_ + 1);
        _SkipfieldType new_skipblock_length = preceding_value + following_value + 1;

        // Join the skipblocks
        g->__skipfield(it.idx_ - preceding_value) = new_skipblock_length;
        g->__skipfield(it.idx_ + following_value) = new_skipblock_length;

        // Remove the following skipblock's entry from the free list
        const _SkipfieldType following_previous = g->element(it.idx_ + 1).nextlink_;
        const _SkipfieldType following_next = g->element(it.idx_ + 1).prevlink_;

        if (following_previous != _SkipMax) {
          it.group_->element(following_previous).prevlink_ = following_next;
        }

        if (following_next != _SkipMax) {
          it.group_->element(following_next).nextlink_ = following_previous;
        } else {
          it.group_->free_list_head = following_previous;
        }
        update_value = following_value + 1;
      }

      iterator result = it.__unconst();
      result.idx_ += update_value;

      if (result.idx_ == g->__index_of_last_endpoint() && g->__next_group != nullptr) {
        result = iterator(g->__next_group, g->__next_group->__skipfield(0));
      }

      if (it == __begin_) {
        __begin_ = result;
      }
      return result;
    } else {
      iterator result;
      if (g->__next_group != nullptr && g->__prev_group != nullptr) {
        g->__next_group->__prev_group = g->__prev_group;
        g->__prev_group->__next_group = g->__next_group;
        result = iterator(g->__next_group, g->__next_group->__skipfield(0));
      } else if (g->__next_group != nullptr) {
        g->__next_group->__prev_group = nullptr;
        __begin_ = iterator(g->__next_group, g->__next_group->__skipfield(0));
        result = __begin_;
      } else if (g->__prev_group != nullptr) {
        g->__prev_group->__next_group = nullptr;
        __end_ = iterator(g->__prev_group, g->__prev_group->capacity);
        result = __end_;
      } else {
        __begin_ = iterator();
        __end_ = iterator();
        result = __end_;
      }
      if (!g->__is_packed()) {
        __remove_from_groups_with_erasures_list(g);
      }
      __unused_groups_push_front(g);
      return result;
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  iterator erase(const_iterator first, const_iterator last) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    allocator_type ea = get_allocator();
    const_iterator current = first;
    if (current.group_ != last.group_) {
      if (current.idx_ != current.group_->__skipfield(0)) {
        size_type number_of_group_erasures = 0;
        _SkipfieldType end = first.group_->__index_of_last_endpoint();
        if (std::is_trivially_destructible<_Tp>::value && current.group_->__is_packed()) {
          number_of_group_erasures += static_cast<size_type>(current.group_->size - current.idx_);
        } else {
          while (current.idx_ != end) {
            if (current.group_->__skipfield(current.idx_) == 0) {
              if constexpr (!std::is_trivially_destructible<_Tp>::value) {
                __alloc_traits::destroy(ea, std::addressof(*current));
              }
              ++number_of_group_erasures;
              ++current.idx_;
            } else {
              const _SkipfieldType prev_free_list_index = current.group_->element(current.idx_).nextlink_;
              const _SkipfieldType next_free_list_index = current.group_->element(current.idx_).prevlink_;
              current.idx_ += current.group_->__skipfield(current.idx_);
              if (next_free_list_index == _SkipMax && prev_free_list_index == _SkipMax) {
                __remove_from_groups_with_erasures_list(first.group_);
                first.group_->free_list_head = _SkipMax;
                number_of_group_erasures += (end - current.idx_);
                if constexpr (!std::is_trivially_destructible<_Tp>::value) {
                  while (current.idx_ != end) {
                    __alloc_traits::destroy(ea, std::addressof(*current));
                    ++current.idx_;
                  }
                }
                break; // end overall while loop
              } else if (next_free_list_index == _SkipMax) {
                current.group_->free_list_head = prev_free_list_index; // make free list head equal to next free list node
                current.group_->element(prev_free_list_index).prevlink_ = _SkipMax;
              } else {
                current.group_->element(next_free_list_index).nextlink_ = prev_free_list_index;
                if (prev_free_list_index != _SkipMax) {
                  current.group_->element(prev_free_list_index).prevlink_ = next_free_list_index;
                }
              }
            }
          }
        }

        const _SkipfieldType previous_node_value = first.group_->__skipfield(first.idx_ - 1);
        const _SkipfieldType distance_to_end = end - first.idx_;

        if (previous_node_value == 0) {
          first.group_->__skipfield(first.idx_) = distance_to_end;
          first.group_->__skipfield(first.idx_ + (distance_to_end - 1)) = distance_to_end;
          if (first.group_->__is_packed()) {
            first.group_->next_erasure_ = std::exchange(__groups_with_erasures_, first.group_);
          } else {
            first.group_->element(first.group_->free_list_head).prevlink_ = first.idx_;
          }

          first.group_->element(first.idx_).nextlink_ = first.group_->free_list_head;
          first.group_->element(first.idx_).prevlink_ = _SkipMax;
          first.group_->free_list_head = first.idx_;
        } else {
          _SkipfieldType new_skipblock_length = previous_node_value + distance_to_end;
          first.group_->__skipfield(first.idx_ - previous_node_value) = new_skipblock_length;
          first.group_->__skipfield(first.idx_ + (distance_to_end - 1)) = new_skipblock_length;
        }
        first.group_->size -= number_of_group_erasures;
        size_ -= number_of_group_erasures;
        current.group_ = current.group_->__next_group;
      }

      // Intermediate groups:
      const _GroupPtr prev = current.group_->__prev_group;
      while (current.group_ != last.group_) {
        if constexpr (!std::is_trivially_destructible<_Tp>::value) {
          current.idx_ = current.group_->__skipfield(0);
          _SkipfieldType end = current.group_->__index_of_last_endpoint();
          do {
            __alloc_traits::destroy(ea, std::addressof(*current));
            current.idx_ += 1 + current.group_->__skipfield(current.idx_ + 1);
          } while (current.idx_ != end);
        }
        if (!current.group_->__is_packed()) {
          __remove_from_groups_with_erasures_list(current.group_);
        }
        size_ -= current.group_->size;
        _GroupPtr current_group = std::exchange(current.group_, current.group_->__next_group);
        __unused_groups_push_front(current_group);
      }

      current.idx_ = current.group_->__skipfield(0);
      current.group_->__prev_group = prev;

      if (prev != nullptr) {
        prev->__next_group = current.group_;
      } else {
        __begin_ = last.__unconst();
      }
    }

    _LIBCPP_ASSERT(current.group_ == last.group_, "");
    if (current == last) {
      return last.__unconst();
    }

    if (last != __end_ || current.idx_ != current.group_->__skipfield(0)) {
      size_type number_of_group_erasures = 0;
      const_iterator current_saved = current;

      if (std::is_trivially_destructible_v<_Tp> && current.group_->__is_packed()) {
        number_of_group_erasures += (last.idx_ - current.idx_);
      } else {
        while (current.idx_ != last.idx_) {
          if (current.group_->__skipfield(current.idx_) == 0) {
            if constexpr (!std::is_trivially_destructible_v<_Tp>) {
              __alloc_traits::destroy(ea, std::addressof(*current));
            }
            ++number_of_group_erasures;
            ++current.idx_;
          } else {
            const _SkipfieldType prev_free_list_index = current.group_->element(current.idx_).nextlink_;
            const _SkipfieldType next_free_list_index = current.group_->element(current.idx_).prevlink_;

            current.idx_ += current.group_->__skipfield(current.idx_);

            if (next_free_list_index == _SkipMax && prev_free_list_index == _SkipMax) {
              __remove_from_groups_with_erasures_list(last.group_);
              last.group_->free_list_head = _SkipMax;
              number_of_group_erasures += (last.idx_ - current.idx_);
              if constexpr (!std::is_trivially_destructible_v<_Tp>) {
                while (current.idx_ != last.idx_) {
                  __alloc_traits::destroy(ea, std::addressof(*current));
                  ++current.idx_;
                }
              }
              break; // end overall while loop
            } else if (next_free_list_index == _SkipMax) {
              current.group_->free_list_head = prev_free_list_index;
              current.group_->element(prev_free_list_index).prevlink_ = _SkipMax;
            } else {
              current.group_->element(next_free_list_index).nextlink_ = prev_free_list_index;
              if (prev_free_list_index != _SkipMax) {
                current.group_->element(prev_free_list_index).prevlink_ = next_free_list_index;
              }
            }
          }
        }
      }

      const _SkipfieldType distance_to_last = (last.idx_ - current_saved.idx_);
      const _SkipfieldType index = current_saved.idx_;

      if (current_saved.idx_ == 0 || current_saved.group_->__skipfield(current_saved.idx_ - 1) == 0) {
        current_saved.group_->__skipfield(current_saved.idx_) = distance_to_last;
        last.group_->__skipfield(last.idx_ - 1) = distance_to_last;

        if (last.group_->__is_packed()) {
          last.group_->next_erasure_ = std::exchange(__groups_with_erasures_, last.group_);
        } else {
          last.group_->element(last.group_->free_list_head).prevlink_ = index;
        }

        current_saved.group_->element(current_saved.idx_).nextlink_ = last.group_->free_list_head;
        current_saved.group_->element(current_saved.idx_).prevlink_ = _SkipMax;
        last.group_->free_list_head = index;
      } else {
        _SkipfieldType prev_node_value = current_saved.group_->__skipfield(current_saved.idx_ - 1);
        _SkipfieldType new_skipblock_length = prev_node_value + distance_to_last;
        current_saved.group_->__skipfield(current_saved.idx_ - prev_node_value) = new_skipblock_length;
        last.group_->__skipfield(last.idx_ - 1) = new_skipblock_length;
      }

      if (first == __begin_) {
        __begin_ = last.__unconst();
      }
      last.group_->size -= number_of_group_erasures;
      size_ -= number_of_group_erasures;
    } else {
      if constexpr (!std::is_trivially_destructible_v<_Tp>) {
        while (current.idx_ != last.idx_) {
          __alloc_traits::destroy(ea, std::addressof(*current));
          current.idx_ += 1 + current.group_->__skipfield(current.idx_ + 1);
        }
      }

      size_ -= current.group_->size;
      if (size_ != 0) {
        if (!current.group_->__is_packed()) {
          __remove_from_groups_with_erasures_list(current.group_);
        }

        current.group_->__prev_group->__next_group = current.group_->__next_group;

        if (current.group_ == __end_.group_) {
          _GroupPtr prev = current.group_->__prev_group;
          __end_ = iterator(prev, prev->__index_of_last_endpoint());
          __unused_groups_push_front(current.group_);
          return __end_;
        } else if (current.group_ == __begin_.group_) {
          _GroupPtr next = current.group_->__next_group;
          __begin_ = iterator(next, next->__skipfield(0));
        }

        if (current.group_->__next_group != __end_.group_) {
          __capacity_ -= current.group_->capacity;
        } else {
          __unused_groups_push_front(current.group_);
          return last.__unconst();
        }
      } else {
        __reset_only_group_left(current.group_);
        return __end_;
      }

      __deallocate_group(current.group_);  // TODO FIXME BUG HACK: don't do this
    }

    return last.__unconst();
  }

  _LIBCPP_HIDE_FROM_ABI
  void swap(hive& __h)
    noexcept(__alloc_traits::propagate_on_container_swap::value || __alloc_traits::is_always_equal::value)
  {
    using std::swap;
    swap(__end_, __h.__end_);
    swap(__begin_, __h.__begin_);
    swap(__groups_with_erasures_, __h.__groups_with_erasures_);
    swap(__unused_groups_, __h.__unused_groups_);
    swap(__unused_groups_tail_, __h.__unused_groups_tail_);
    swap(size_, __h.size_);
    swap(__capacity_, __h.__capacity_);
    if constexpr (__alloc_traits::propagate_on_container_swap::value && !__alloc_traits::is_always_equal::value) {
      swap(__allocator_, __h.__allocator_);
    }
  }

  friend void swap(hive& __a, hive& __b) noexcept(noexcept(__a.swap(__b))) { __a.swap(__b); }

  _LIBCPP_HIDE_FROM_ABI
  void clear() noexcept {
    if (size_ != 0) {
      if constexpr (!std::is_trivially_destructible_v<_Tp>) {
        allocator_type ea = get_allocator();
        for (iterator it = __begin_; it != __end_; ++it) {
          __alloc_traits::destroy(ea, std::addressof(*it));
        }
      }
      if (__begin_.group_ != __end_.group_) {
        // Move all other groups onto the unused_groups list
        __end_.group_->__next_group = __unused_groups_;
        if (__unused_groups_ == nullptr) {
          __unused_groups_tail_ = __end_.group_;
        }
        __unused_groups_ = __begin_.group_->__next_group;
      }
      __reset_only_group_left(__begin_.group_);
      __groups_with_erasures_ = nullptr;
      size_ = 0;
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void splice(hive& __source) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    _LIBCPP_ASSERT(&__source != this, "");

    if (__capacity_ + __source.__capacity_ > max_size()) {
      std::__throw_length_error("Result of splice would exceed max_size()");
    }

    size_type __trailing = __trailing_capacity();
    if (__trailing > __source.__trailing_capacity()) {
      __source.splice(*this);
      swap(__source);
    } else {
      if (__source.__groups_with_erasures_ != nullptr) {
        if (__groups_with_erasures_ == nullptr) {
          __groups_with_erasures_ = __source.__groups_with_erasures_;
        } else {
          _GroupPtr tail = __groups_with_erasures_;
          while (tail->next_erasure_ != nullptr) {
            tail = tail->next_erasure_;
          }
          tail->next_erasure_ = __source.__groups_with_erasures_;
        }
      }
      if (__source.__unused_groups_ != nullptr) {
        if (__unused_groups_ == nullptr) {
          __unused_groups_ = std::exchange(__source.__unused_groups_, nullptr);
        } else {
          __unused_groups_tail_->__next_group = std::exchange(__source.__unused_groups_, nullptr);
        }
        __unused_groups_tail_ = std::exchange(__source.__unused_groups_tail_, nullptr);
      }
      if (__trailing != 0 && __source.__begin_.group_ != nullptr) {
        __unspecialcase_end_group(__end_.group_);
      }
      if (__source.__begin_.group_ != nullptr) {
        __source.__begin_.group_->__prev_group = __end_.group_;
        if (__end_.group_ != nullptr) {
          __end_.group_->__next_group = __source.__begin_.group_;
#if PLF_HIVE_RELATIONAL_OPERATORS
          if (__source.__begin_.group_->__group_number() <= __end_.group_->__group_number()) {
            __renumber_all_groups();
          }
#endif
        } else {
          _LIBCPP_ASSERT(__begin_.group_ == nullptr, "");
          __begin_ = std::move(__source.__begin_);
        }
        __end_ = std::move(__source.__end_);
      }
      size_ += std::exchange(__source.size_, 0);
      __capacity_ += std::exchange(__source.__capacity_, 0);

      __source.__begin_ = iterator();
      __source.__end_ = iterator();
      __source.__groups_with_erasures_ = nullptr;
    }
    __source.__assert_invariants();
  }

  _LIBCPP_HIDE_FROM_ABI void splice(hive&& __source) { this->splice(__source); }

  void resize(size_type __n) {
    if (size() < __n) {
      __callback_insert_impl(__n - size(), __make_zero_argument_callback());
    } else {
      iterator __it = end();
      __it.__advance_backward(size() - __n);
      erase(__it, end());
    }
    _LIBCPP_ASSERT(size() == __n, "");
  }

  template <class _InputIterator>
    requires __is_cpp17_input_iterator<_InputIterator>::value
  _LIBCPP_HIDE_FROM_ABI
  void assign(_InputIterator __first, _InputIterator __last) {
    __range_assign_impl(std::move(__first), std::move(__last));
  }

#if _LIBCPP_STD_VER >= 23
  template <__container_compatible_range<value_type> _Rp>
  _LIBCPP_HIDE_FROM_ABI
  void assign_range(_Rp&& __r) {
    _LIBCPP_ASSERT((assignable_from<value_type&, std::ranges::range_reference_t<_Rp>>), "mandated");
    __range_assign_impl(std::ranges::begin(__r), std::ranges::end(__r));
  }
#endif

  _LIBCPP_HIDE_FROM_ABI
  void assign(size_type __n, const value_type& __value) {
    clear();
    insert(__n, __value);
  }

  _LIBCPP_HIDE_FROM_ABI
  void assign(std::initializer_list<_Tp> __il) {
    __range_assign_impl(__il.begin(), __il.end());
  }

  _LIBCPP_HIDE_FROM_ABI allocator_type get_allocator() const noexcept { return __allocator_; }

  _LIBCPP_HIDE_FROM_ABI iterator begin() noexcept { return __begin_; }
  _LIBCPP_HIDE_FROM_ABI const_iterator begin() const noexcept { return __begin_; }
  _LIBCPP_HIDE_FROM_ABI iterator end() noexcept { return __end_; }
  _LIBCPP_HIDE_FROM_ABI const_iterator end() const noexcept { return __end_; }
  _LIBCPP_HIDE_FROM_ABI reverse_iterator rbegin() noexcept { return reverse_iterator(__end_); }
  _LIBCPP_HIDE_FROM_ABI const_reverse_iterator rbegin() const noexcept { return const_reverse_iterator(__end_); }
  _LIBCPP_HIDE_FROM_ABI reverse_iterator rend() noexcept { return reverse_iterator(__begin_); }
  _LIBCPP_HIDE_FROM_ABI const_reverse_iterator rend() const noexcept { return const_reverse_iterator(__begin_); }
  _LIBCPP_HIDE_FROM_ABI const_iterator cbegin() const noexcept { return __begin_; }
  _LIBCPP_HIDE_FROM_ABI const_iterator cend() const noexcept { return __end_; }
  _LIBCPP_HIDE_FROM_ABI const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator(__end_); }
  _LIBCPP_HIDE_FROM_ABI const_reverse_iterator crend() const noexcept { return const_reverse_iterator(__begin_); }

  _LIBCPP_HIDE_FROM_ABI reference front() { return *begin(); }
  _LIBCPP_HIDE_FROM_ABI const_reference front() const { return *begin(); }
  _LIBCPP_HIDE_FROM_ABI reference back() { auto __it = end(); --__it; return *__it; }
  _LIBCPP_HIDE_FROM_ABI const_reference back() const { auto __it = end(); --__it; return *__it; }

  [[nodiscard]] _LIBCPP_HIDE_FROM_ABI bool empty() const noexcept { return size_ == 0; }
  _LIBCPP_HIDE_FROM_ABI size_type size() const noexcept { return size_; }

  _LIBCPP_HIDE_FROM_ABI
  size_type max_size() const noexcept {
    return std::min<size_type>(__alloc_traits::max_size(get_allocator()),
                   numeric_limits<difference_type>::max());
  }

  _LIBCPP_HIDE_FROM_ABI size_type capacity() const noexcept { return __capacity_; }

  _LIBCPP_HIDE_FROM_ABI
  size_type max_block_size() const noexcept {
    size_type __a = __impl_max_block_size();
    size_type __b = max_size();
    return __a < __b ? __a : __b;
  }

  _LIBCPP_HIDE_FROM_ABI
  bool reshape(size_type __min, size_type __n = 0) {
    if (__n > max_size()) {
      std::__throw_length_error("n must be at most max_size()");
    }
    if (__min > max_block_size()) {
      std::__throw_length_error("min must be at most max_block_size()");
    }
    __reshape_impl_deallocate_unused_groups(__min, _SkipMax);
    size_type __oldsize = size();
    hive __other(get_allocator());
    for (_GroupPtr __g = __begin_.group_; __g != nullptr; ) {
      _GroupPtr __next = __g->__next_group;
      _LIBCPP_ASSERT(__g->size >= 1, "");
      if (__g->capacity < __min) {
        __other.__transfer_group_impl(*this, __g);
      }
      __g = __next;
    }
    __assert_invariants();
    __other.__assert_invariants();
    if (__other.empty()) {
      return false;
    } else {
      std::__hive_try_rollback([&]() {
        __reserve_impl(__oldsize, __min, max_block_size());
        while (!__other.empty()) {
          emplace(std::move(*__other.begin()));
          __other.erase(__other.begin());
        }
      }, [&]() {
        this->splice(__other);
      });
      return true;
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  hive& operator=(const hive& __source) {
    if constexpr (__alloc_traits::propagate_on_container_copy_assignment::value) {
      allocator_type __source_allocator = __source.get_allocator();
      if (!__alloc_traits::is_always_equal::value && get_allocator() != __source_allocator) {
        // Deallocate existing blocks as source allocator is not necessarily able to do so
        __destroy_all_data();
        __blank();
      }
      __allocator_ = std::move(__source_allocator);
    }
    __range_assign_impl(__source.begin(), __source.end());
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI
  hive& operator=(hive&& __source)
    noexcept(__alloc_traits::propagate_on_container_move_assignment::value ||
             __alloc_traits::is_always_equal::value)
  {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    _LIBCPP_ASSERT(std::addressof(__source) != this, "");
    __destroy_all_data();

    bool __should_use_source_allocator = (
      __alloc_traits::propagate_on_container_move_assignment::value ||
      __alloc_traits::is_always_equal::value ||
      this->get_allocator() == __source.get_allocator()
    );
    if (__should_use_source_allocator) {
      constexpr bool __can_just_memcpy = (
        std::is_trivially_copyable_v<allocator_type> &&
        std::is_trivial_v<_GroupPtr> &&
        std::is_trivial_v<_OveralignedEltPtr> &&
        std::is_trivial_v<_SkipfieldPtr>
      );
      if constexpr (__can_just_memcpy) {
        ::__builtin_memcpy(static_cast<void *>(this), std::addressof(__source), sizeof(hive));
      } else {
        __end_ = std::move(__source.__end_);
        __begin_ = std::move(__source.__begin_);
        __groups_with_erasures_ = std::move(__source.__groups_with_erasures_);
        __unused_groups_ = std::move(__source.__unused_groups_);
        __unused_groups_tail_ = std::move(__source.__unused_groups_tail_);
        size_ = __source.size_;
        __capacity_ = __source.__capacity_;
        if constexpr (__alloc_traits::propagate_on_container_move_assignment::value) {
          __allocator_ = std::move(__source.__allocator_);
        }
      }
    } else {
      reserve(__source.size());
      __range_assign_impl(std::make_move_iterator(__source.begin()), std::make_move_iterator(__source.end()));
      __source.__destroy_all_data();
    }
    __source.__blank();
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI
  hive& operator=(std::initializer_list<_Tp> __il) {
    __range_assign_impl(__il.begin(), __il.end());
    return *this;
  }

  _LIBCPP_HIDE_FROM_ABI
  void shrink_to_fit() {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    const size_type __min = __impl_min_block_size();
    const size_type __max = __impl_max_block_size();
    trim_capacity();
    size_type __oldsize = size();
    hive __other(get_allocator());
    for (_GroupPtr __g = __begin_.group_; __g != nullptr; ) {
      _GroupPtr __next = __g->__next_group;
      if (__next != nullptr) {
        if (__g->size != __max) {
          __other.__transfer_group_impl(*this, __g);
        }
      } else {
        if (__g->capacity > __min && __g->capacity > __g->size) {
          __other.__transfer_group_impl(*this, __g);
        }
      }
      __g = __next;
    }
    __assert_invariants();
    __other.__assert_invariants();
    if (!__other.empty()) {
      std::__hive_try_rollback([&]() {
        reserve(__oldsize);
        while (!__other.empty()) {
          emplace(std::move(*__other.begin()));
          __other.erase(__other.begin());
        }
      }, [&]() {
        this->splice(__other);
      });
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void trim_capacity() noexcept {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    for (_GroupPtr __g = __unused_groups_; __g != nullptr; ) {
      _GroupPtr __next = __g->__next_group;
      __capacity_ -= __g->capacity;
      __deallocate_group(__g);
      __g = __next;
    }
    __unused_groups_ = nullptr;
    __unused_groups_tail_ = nullptr;
  }

  _LIBCPP_HIDE_FROM_ABI
  void reserve(size_type __n) {
    __reserve_impl(__n, __impl_min_block_size(), __impl_max_block_size());
  }

  template <class _Comp>
  _LIBCPP_HIDE_FROM_ABI
  void sort(_Comp __less) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    if (size_ <= 1) {
      return;
    }

    struct _ItemT {
      _Tp *__ptr_;
      size_type __idx_;
    };

    std::unique_ptr<_ItemT[]> __a = std::make_unique<_ItemT[]>(size_);
    auto __it = __begin_;
    for (size_type __i = 0; __i < size_; ++__i) {
      __a[__i] = _ItemT{std::addressof(*__it), __i};
      ++__it;
    }
    _LIBCPP_ASSERT(__it == __end_, "");
    std::sort(__a.get(), __a.get() + size_, [&](const _ItemT& __x, const _ItemT& __y) { return __less(*__x.__ptr_, *__y.__ptr_); });

    for (size_type __i = 0; __i < size_; ++__i) {
      size_type __src = __a[__i].__idx_;
      size_type __dest = __i;
      if (__src != __dest) {
        _Tp __temp = std::move(*__a[__i].__ptr_);
        do {
          *__a[__dest].__ptr_ = std::move(*__a[__src].__ptr_);
          __dest = __src;
          __src = __a[__dest].__idx_;
          __a[__dest].__idx_ = __dest;
        } while (__src != __i);
        *__a[__dest].__ptr_ = std::move(__temp);
      }
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void sort() { sort(std::less<_Tp>()); }

  template <class _Comp>
  _LIBCPP_HIDE_FROM_ABI
  size_type unique(_Comp __eq) {
    // h.unique() must not invalidate iterators, except to the erased elements and end().
    // It is not allowed to compact the hive.
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    size_type __count = 0;
    iterator __end = end();
    for (iterator __it = begin(); __it != __end; ) {
      iterator __previous = __it;
      ++__it;
      if (__it == __end) {
        break;
      }
      if (__eq(*__it, *__previous)) {
        size_type __orig = ++__count;
        iterator __last = __it;
        while (++__last != __end && __eq(*__last, *__previous)) {
          ++__count;
        }
        if (__count != __orig) {
          __it = erase(__it, __last);
        } else {
          __it = erase(__it);
        }
        __end = end();
      }
    }
    return __count;
  }

  _LIBCPP_HIDE_FROM_ABI
  size_type unique() { return unique(std::equal_to<_Tp>()); }

  _LIBCPP_HIDE_FROM_ABI
  friend bool operator==(const hive& __x, const hive& __y) {
    if (__x.size() != __y.size()) {
      return false;
    }
    return std::equal(__x.begin(), __x.end(), __y.begin(), __y.end());
  }

  _LIBCPP_HIDE_FROM_ABI
  friend auto operator<=>(const hive& __x, const hive& __y) {
    return std::lexicographical_compare_three_way(__x.begin(), __x.end(), __y.begin(), __y.end(), __synth_three_way);
  }

private:
  _LIBCPP_HIDE_FROM_ABI static constexpr size_type __impl_min_block_size() { return 3; }
  _LIBCPP_HIDE_FROM_ABI static constexpr size_type __impl_max_block_size() { return _SkipMax; }

  _LIBCPP_HIDE_FROM_ABI
  size_type __recommend_block_size() const {
    size_type __r = size_;
    if (__r < 8) __r = 8;
    if (__r > __impl_max_block_size()) __r = __impl_max_block_size();
    return __r;
  }

  _LIBCPP_HIDE_FROM_ABI
  void __reserve_impl(size_type n, size_type min, size_type max) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    if (n <= __capacity_) {
      return;
    } else if (n > max_size()) {
      std::__throw_length_error("n must be at most max_size()");
    }
    size_type needed = n - __capacity_;
    while (needed >= max) {
      __allocate_unused_group(max);
      needed -= max;
    }
    if (needed != 0) {
      if (needed < min) {
        needed = min;
      }
      bool __should_move_to_back_of_list = (__unused_groups_ != nullptr && __unused_groups_->capacity > needed);
      __allocate_unused_group(needed);
      if (__should_move_to_back_of_list) {
        _GroupPtr g = __unused_groups_pop_front();
        std::exchange(__unused_groups_tail_, g)->__next_group = g;
        g->__next_group = nullptr;
      }
    }
    _LIBCPP_ASSERT(__capacity_ >= n, "");
  }

  _LIBCPP_HIDE_FROM_ABI
  void __reshape_impl_deallocate_unused_groups(size_t __min, size_t __max) {
    _GroupPtr __g = __unused_groups_;
    _GroupPtr __prev = nullptr;
    while (__g != nullptr) {
      if (__g->capacity < __min || __g->capacity > __max) {
        if (__prev != nullptr) {
          __prev->__next_group = __g->__next_group;
        } else {
          __unused_groups_ = __g->__next_group;
        }
        if (__g->__next_group == nullptr) {
          __unused_groups_tail_ = __prev;
        }
        __capacity_ -= __g->capacity;
        __deallocate_group(std::exchange(__g, __g->__next_group));
      } else {
        __prev = std::exchange(__g, __g->__next_group);
      }
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void __transfer_group_impl(hive& h, _GroupPtr g) {
    if (g->__prev_group != nullptr && g->__next_group != nullptr) {
      g->__prev_group->__next_group = g->__next_group;
      g->__next_group->__prev_group = g->__prev_group;
    } else if (g->__prev_group != nullptr) {
      g->__prev_group->__next_group = g->__next_group;
      h.__end_ = iterator(g->__prev_group, g->__prev_group->capacity);
    } else if (g->__next_group != nullptr) {
      g->__next_group->__prev_group = g->__prev_group;
      h.__begin_ = iterator(g->__next_group, g->__next_group->__skipfield(0));
    } else {
      h.__begin_ = iterator();
      h.__end_ = iterator();
    }
    if (!g->__is_packed()) {
      h.__remove_from_groups_with_erasures_list(g);
      g->next_erasure_ = std::exchange(__groups_with_erasures_, g);
    }
    h.__capacity_ -= g->capacity;
    h.size_ -= g->size;
    g->__next_group = nullptr;
    g->__prev_group = __end_.group_;
    if (__end_.group_ != nullptr) {
      __end_.group_->__next_group = g;
    } else {
      __begin_ = iterator(g, g->__skipfield(0));
    }
    __end_ = iterator(g, g->__index_of_last_endpoint());
    __capacity_ += g->capacity;
    size_ += g->size;
  }

  _LIBCPP_HIDE_FROM_ABI
  size_type __trailing_capacity() const {
    if (__end_.group_ == nullptr) {
      return 0;
    } else {
      return (__end_.group_->capacity - __end_.__index_in_group());
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void __blank() {
    __end_ = iterator();
    __begin_ = iterator();
    __groups_with_erasures_ = nullptr;
    __unused_groups_ = nullptr;
    __unused_groups_tail_ = nullptr;
    size_ = 0;
    __capacity_ = 0;
  }

#if PLF_HIVE_RELATIONAL_OPERATORS
  _LIBCPP_HIDE_FROM_ABI
  void __renumber_all_groups() {
    size_type __groupno = 0;
    for (_GroupPtr __g = __begin_.group_; __g != nullptr; __g = __g->__next_group) {
      __g->__set_group_number(__groupno++);
    }
  }
#else
  _LIBCPP_HIDE_FROM_ABI void __renumber_all_groups() { }
#endif

  template <bool MightFillIt, class _Callback>
  _LIBCPP_HIDE_FROM_ABI
  void __callback_fill_skipblock(_SkipfieldType n, _Callback __cb, _GroupPtr g) {
    _LIBCPP_ASSERT(g == __groups_with_erasures_, "");
    allocator_type ea = get_allocator();
    _SkipfieldType sb = g->free_list_head;
    _OveralignedEltPtr d_first = g->__addr_of_element(sb);
    _OveralignedEltPtr d_last = d_first + n;
    _SkipfieldType nextsb = d_first[0].nextlink_;
    _SkipfieldType old_skipblock_length = g->__skipfield(sb);
    _LIBCPP_ASSERT(1 <= n && n <= old_skipblock_length, "");
    _LIBCPP_ASSERT(g->__skipfield(sb + old_skipblock_length - 1) == old_skipblock_length, "");
    _OveralignedEltPtr p = d_first;
    std::__hive_try_finally([&]() {
      while (p != d_last) {
        __cb.__construct_and_increment(ea, p);
      }
    }, [&]() {
      _SkipfieldType nadded = p - d_first;
      g->size += nadded;
      size_ += nadded;
      if (nadded != 0 && d_first == __begin_.group_->__addr_of_element(0)) {
        __begin_ = iterator(g, 0);
      }
      std::fill_n(g->__addr_of_skipfield(sb), nadded, _SkipfieldType());
      _SkipfieldType new_skipblock_length = (old_skipblock_length - nadded);
      if (MightFillIt && new_skipblock_length == 0) {
        g->free_list_head = nextsb;
        if (nextsb == _SkipMax) {
          __groups_with_erasures_ = g->next_erasure_;
        }
      } else {
        g->__skipfield(sb + nadded) = new_skipblock_length;
        g->__skipfield(sb + old_skipblock_length - 1) = new_skipblock_length;
        g->free_list_head = sb + nadded;
        g->element(sb + nadded).prevlink_ = _SkipMax;
        g->element(sb + nadded).nextlink_ = nextsb;
        if (nextsb != _SkipMax) {
          g->element(nextsb).prevlink_ = sb + nadded;
        }
      }
    });
  }

  template <class _Callback>
  _LIBCPP_HIDE_FROM_ABI
  void __callback_fill_trailing_capacity(_SkipfieldType n, _Callback __cb, _GroupPtr g) {
    allocator_type ea = get_allocator();
    _LIBCPP_ASSERT(g == __end_.group_, "");
    _LIBCPP_ASSERT(g->__is_packed(), "");
    _LIBCPP_ASSERT(1 <= n && n <= g->capacity - g->size, "");
    _LIBCPP_ASSERT(g->__next_group == nullptr, "");
    _OveralignedEltPtr d_first = g->last_endpoint;
    _OveralignedEltPtr d_last = g->last_endpoint + n;
    _OveralignedEltPtr p = d_first;
    std::__hive_try_finally([&]() {
      while (p != d_last) {
        __cb.__construct_and_increment(ea, p);
      }
    }, [&]() {
      _SkipfieldType nadded = p - d_first;
      g->last_endpoint = p;
      g->size += nadded;
      size_ += nadded;
      __end_ = iterator(g, p - g->__addr_of_element(0));
    });
  }

  template <class _Callback>
  _LIBCPP_HIDE_FROM_ABI
  void __callback_fill_unused_group(_SkipfieldType n, _Callback __cb, _GroupPtr g) {
    if (__end_.group_ != nullptr && __end_.group_->__group_number() == _SkipMax) {
      __renumber_all_groups();
    }
    allocator_type ea = get_allocator();
    _LIBCPP_ASSERT(g == __unused_groups_, "");
    _LIBCPP_ASSERT(1 <= n && n <= g->capacity, "");
    _OveralignedEltPtr d_first = g->__addr_of_element(0);
    _OveralignedEltPtr d_last = g->__addr_of_element(n);
    _OveralignedEltPtr p = d_first;
    std::__hive_try_finally([&]() {
      while (p != d_last) {
        __cb.__construct_and_increment(ea, p);
      }
    }, [&]() {
      _SkipfieldType nadded = p - d_first;
      if (nadded != 0) {
        (void)__unused_groups_pop_front();
        std::fill_n(g->__addr_of_skipfield(0), g->capacity, _SkipfieldType());
        g->free_list_head = _SkipMax;
        g->last_endpoint = p;
        g->size = nadded;
        size_ += nadded;
        g->__next_group = nullptr;
        if (__end_.group_ != nullptr) {
          if (__end_.group_->__group_number() == _SkipMax) {
            __renumber_all_groups();
          }
          __end_.group_->__next_group = g;
          g->__prev_group = __end_.group_;
          g->__set_group_number(__end_.group_->__group_number() + 1);
        } else {
          g->__prev_group = nullptr;
          g->__set_group_number(0);
        }
        __end_ = iterator(g, nadded);
        if (__begin_.group_ == nullptr) {
          __begin_ = iterator(g, 0);
        }
      } else {
        _LIBCPP_ASSERT(g == __unused_groups_, "");
        _LIBCPP_ASSERT(g != __end_.group_, "");
      }
    });
  }

  template <class _Callback>
  _LIBCPP_HIDE_FROM_ABI
  void __callback_insert_impl(size_type n, _Callback __cb) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    reserve(size_ + n);
    while (__groups_with_erasures_ != nullptr) {
      _GroupPtr g = __groups_with_erasures_;
      _LIBCPP_ASSERT(g->free_list_head != _SkipMax, "");
      _SkipfieldType skipblock_length = g->__skipfield(g->free_list_head);
      if (skipblock_length > n) {
        __callback_fill_skipblock<false>(n, __cb, g);
        return;
      } else {
        __callback_fill_skipblock<true>(skipblock_length, __cb, g);
        n -= skipblock_length;
        if (n == 0) {
          return;
        }
      }
    }
    if (n != 0 && __end_.group_ != nullptr) {
      _GroupPtr g = __end_.group_;
      _LIBCPP_ASSERT(g->__is_packed(), "");
      size_type space = g->capacity - g->size;
      if (space >= n) {
        __callback_fill_trailing_capacity(n, __cb, g);
        return;
      } else if (space != 0) {
        __callback_fill_trailing_capacity(space, __cb, g);
        n -= space;
      }
    }
    while (n != 0) {
      _GroupPtr g = __unused_groups_;
      if (g->capacity >= n) {
        __callback_fill_unused_group(n, __cb, g);
        return;
      } else {
        __callback_fill_unused_group(g->capacity, __cb, g);
        n -= g->capacity;
      }
    }
  }

  template <class _It, class _Sent>
  _LIBCPP_HIDE_FROM_ABI
  void __range_assign_impl(_It __first, _Sent __last) {
    if constexpr (!forward_iterator<_It>) {
      clear();
      for ( ; __first != __last; ++__first) {
        emplace(*__first);
      }
    } else if (__first == __last) {
      clear();
    } else {
      size_type __n = std::ranges::distance(__first, __last);
      clear();
      __callback_insert_impl(__n, __make_itpair_callback(__first));
    }
  }

  template <class _It, class _Sent>
  _LIBCPP_HIDE_FROM_ABI
  void __range_insert_impl(_It __first, _Sent __last) {
    if constexpr (!forward_iterator<_It>) {
      for ( ; __first != __last; ++__first) {
        emplace(*__first);
      }
    } else if (__first == __last) {
      return;
    } else {
      size_type __n = std::ranges::distance(__first, __last);
      __callback_insert_impl(__n, __make_itpair_callback(__first));
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void __update_subsequent_group_numbers(_GroupPtr __g) {
#if PLF_HIVE_RELATIONAL_OPERATORS
    do {
      __g->groupno_ -= 1;
      __g = __g->__next_group;
    } while (__g != nullptr);
#endif
    (void)__g;
  }

  _LIBCPP_HIDE_FROM_ABI
  void __remove_from_groups_with_erasures_list(_GroupPtr __g) {
    _LIBCPP_ASSERT(__groups_with_erasures_ != nullptr, "");
    if (__g == __groups_with_erasures_) {
      __groups_with_erasures_ = __groups_with_erasures_->next_erasure_;
    } else {
      _GroupPtr __prev = __groups_with_erasures_;
      _GroupPtr __curr = __groups_with_erasures_->next_erasure_;
      while (__g != __curr) {
        __prev = __curr;
        __curr = __curr->next_erasure_;
      }
      __prev->next_erasure_ = __curr->next_erasure_;
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void __reset_only_group_left(_GroupPtr __g) {
    __groups_with_erasures_ = nullptr;
    __g->reset(0, nullptr, nullptr, 0);
    __begin_ = iterator(__g, 0);
    __end_ = __begin_;
  }

  void __unused_groups_push_front(_GroupPtr __g) {
    __g->__next_group = std::exchange(__unused_groups_, __g);
    if (__unused_groups_tail_ == nullptr) {
      __unused_groups_tail_ = __g;
    }
  }

  _GroupPtr __unused_groups_pop_front() {
    _GroupPtr __g = std::exchange(__unused_groups_, __unused_groups_->__next_group);
    _LIBCPP_ASSERT(__g != nullptr, "");
    if (__unused_groups_tail_ == __g) {
      __unused_groups_tail_ = nullptr;
    }
    return __g;
  }

  struct _GroupAllocHelper {
    union _Up {
      group __g_;
      _OveralignedElt __elt_;
    };
    struct type {
      alignas(_Up) char __dummy_[sizeof(_Up)];
    };

    static _OveralignedEltPtr __elements(group* __g) {
      char* __base = (char*)__g;
      auto* __p = (_OveralignedElt*)(__base + sizeof(_Up));
      return std::pointer_traits<_OveralignedEltPtr>::pointer_to(*__p);
    }

    static _SkipfieldPtr __skipfield(group* __g) {
      return _SkipfieldPtr(__elements(__g) + __g->capacity);
    }

    static _GroupPtr __allocate_group(allocator_type a, size_t cap) {
      auto ta = _AllocOf<type>(a);
      size_t bytes_for_group = sizeof(_Up);
      size_t bytes_for_elts = sizeof(_OveralignedElt) * cap;
      size_t bytes_for_skipfield = sizeof(_SkipfieldType) * (cap + 1);
      size_t n = (bytes_for_group + bytes_for_elts + bytes_for_skipfield + sizeof(type) - 1) / sizeof(type);
      _PtrOf<type> p = std::allocator_traits<_AllocOf<type>>::allocate(ta, n);
      _GroupPtr g = _PtrOf<group>(p);
      ::new ((void*)std::addressof(*g)) group(cap);
      return g;
    }
    static void __deallocate_group(allocator_type a, _GroupPtr g) {
      size_t cap = g->capacity;
      auto ta = _AllocOf<type>(a);
      size_t bytes_for_group = sizeof(_Up);
      size_t bytes_for_elts = sizeof(_OveralignedElt) * cap;
      size_t bytes_for_skipfield = sizeof(_SkipfieldType) * (cap + 1);
      size_t n = (bytes_for_group + bytes_for_elts + bytes_for_skipfield + sizeof(type) - 1) / sizeof(type);
      std::allocator_traits<_AllocOf<type>>::deallocate(ta, _PtrOf<type>(g), n);
    }
  };

  _LIBCPP_HIDE_FROM_ABI
  void __allocate_unused_group(size_type cap) {
    _GroupPtr g = _GroupAllocHelper::__allocate_group(get_allocator(), cap);
    __unused_groups_push_front(g);
    __capacity_ += cap;
  }

  _LIBCPP_HIDE_FROM_ABI
  void __deallocate_group(_GroupPtr g) {
    _GroupAllocHelper::__deallocate_group(get_allocator(), g);
  }

  _LIBCPP_HIDE_FROM_ABI
  void __unspecialcase_end_group(_GroupPtr g) {
    _LIBCPP_ASSERT(g == __end_.group_, "");
    size_type __trailing = g->__end_of_elements() - g->last_endpoint;
    size_type sb = g->capacity - __trailing;
    if (__trailing != 0) {
      g->__skipfield(sb) = __trailing;
      g->__skipfield(g->capacity - 1) = __trailing;
      if (g->free_list_head == _SkipMax) {
        g->next_erasure_ = std::exchange(__groups_with_erasures_, g);
      }
      g->element(sb).nextlink_ = std::exchange(g->free_list_head, sb);
      g->element(sb).prevlink_ = _SkipMax;
      g->last_endpoint = g->__end_of_elements();
    }
  }

  _LIBCPP_HIDE_FROM_ABI
  void __destroy_all_data() {
    if (_GroupPtr __g = __begin_.group_) {
      __end_.group_->__next_group = __unused_groups_;

      if constexpr (!std::is_trivially_destructible<_Tp>::value) {
        if (size_ != 0) {
          while (true) {
            // Destroy the elements without bothering to update the skipfields.
            _SkipfieldType __end_pointer = __g->__index_of_last_endpoint();
            do {
              __alloc_traits::destroy(__allocator_, std::addressof(*__begin_));
              __begin_.idx_ += 1 + __begin_.group_->__skipfield(__begin_.idx_ + 1);
            } while (__begin_.idx_ != __end_pointer); // ie. beyond end of available data

            _GroupPtr __next = __g->__next_group;
            __deallocate_group(__g);
            __g = __next;

            if (__g == __unused_groups_) {
              break;
            }
            __begin_ = iterator(__g, __g->__skipfield(0));
          }
        }
      }

      while (__g != nullptr) {
        _GroupPtr __next = __g->__next_group;
        __deallocate_group(__g);
        __g = __next;
      }
    }
  }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI
  iterator __unchecked_emplace_at_end(_Args&&... __args) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    _LIBCPP_ASSERT(__trailing_capacity() != 0, "");
    allocator_type __ea = get_allocator();
    iterator __result = __end_;
    _GroupPtr __g = __result.group_;
    __alloc_traits::construct(__ea, std::addressof(*__result), static_cast<_Args&&>(__args)...);
    _LIBCPP_ASSERT(__end_.group_->__skipfield(__end_.idx_) == 0, "");
    ++__end_.idx_;
    __g->last_endpoint += 1;
    __g->size += 1;
    ++size_;
    return __result;
  }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI
  iterator __unchecked_emplace_in_hole(_Args&&... __args) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    _LIBCPP_ASSERT(__groups_with_erasures_ != nullptr, "");
    allocator_type __ea = get_allocator();
    _GroupPtr __g = __groups_with_erasures_;
    _SkipfieldType __sb = __g->free_list_head;
    _LIBCPP_ASSERT(__sb < __g->capacity, "");
    iterator __result = iterator(__g, __sb);
    _SkipfieldType __nextsb = __g->element(__sb).nextlink_;
    _LIBCPP_ASSERT(__g->element(__sb).prevlink_ == _SkipMax, "");
    std::__hive_try_rollback([&]() {
      __alloc_traits::construct(__ea, std::addressof(*__result), static_cast<_Args&&>(__args)...);
    }, [&]() {
      __g->element(__sb).prevlink_ = _SkipMax;
      __g->element(__sb).nextlink_ = __nextsb;
    });
    __g->size += 1;
    size_ += 1;
    if (__g == __begin_.group_ && __sb == 0) {
      __begin_ = __result;
    }
    _SkipfieldType __old_skipblock_length = std::exchange(__g->__skipfield(__sb), 0);
    _LIBCPP_ASSERT(1 <= __old_skipblock_length && __old_skipblock_length <= __g->capacity, "");
    _SkipfieldType __new_skipblock_length = (__old_skipblock_length - 1);
    if (__new_skipblock_length == 0) {
      __g->free_list_head = __nextsb;
      if (__nextsb == _SkipMax) {
        __groups_with_erasures_ = __g->next_erasure_;
      } else {
        __g->element(__nextsb).prevlink_ = _SkipMax;
      }
    } else {
      __g->__skipfield(__sb + 1) = __new_skipblock_length;
      __g->__skipfield(__sb + __old_skipblock_length - 1) = __new_skipblock_length;
      __g->free_list_head = __sb + 1;
      __g->element(__sb + 1).prevlink_ = _SkipMax;
      __g->element(__sb + 1).nextlink_ = __nextsb;
      if (__nextsb != _SkipMax) {
        __g->element(__nextsb).prevlink_ = __sb + 1;
      }
    }
    return __result;
  }

  template <class... _Args>
  _LIBCPP_HIDE_FROM_ABI
  iterator __unchecked_emplace_in_new_group_at_end(_Args&&... __args) {
    _LIBCPP_HIVE_ASSERT_INVARIANTS_GUARD
    allocator_type __ea = get_allocator();
    if (__unused_groups_ == nullptr) {
      __allocate_unused_group(__recommend_block_size());
    }
    _GroupPtr __g = __unused_groups_;
    __alloc_traits::construct(__ea, __g->element(0).__t(), static_cast<_Args&&>(__args)...);
    (void)__unused_groups_pop_front();
    std::fill_n(__g->__addr_of_skipfield(0), __g->capacity, _SkipfieldType());
    __g->size = 1;
    __g->last_endpoint = __g->__addr_of_element(1);
    __g->free_list_head = _SkipMax;
    __g->__next_group = nullptr;
    __g->__prev_group = __end_.group_;
    iterator __result = iterator(__g, 0);
    if (__end_.group_ != nullptr) {
      if (__end_.group_->__group_number() == _SkipMax) {
        __renumber_all_groups();
      }
      __end_.group_->__next_group = __g;
      __g->__set_group_number(__end_.group_->__group_number() + 1);
    } else {
      __begin_ = __result;
      __g->__set_group_number(0);
    }
    __end_ = iterator(__g, 1);
    ++size_;
    return __result;
  }

  iterator __end_;
  iterator __begin_;
  _GroupPtr __groups_with_erasures_ = _GroupPtr();
  _GroupPtr __unused_groups_ = _GroupPtr();
  _GroupPtr __unused_groups_tail_ = _GroupPtr();
  size_type size_ = 0;
  size_type __capacity_ = 0;
  _LIBCPP_NO_UNIQUE_ADDRESS allocator_type __allocator_;
};

template <class _InputIterator,
      class _Allocator = allocator<__iter_value_type<_InputIterator>>,
      class = enable_if_t<__is_cpp17_input_iterator<_InputIterator>::value>,
      class = enable_if_t<__is_allocator<_Allocator>::value>>
hive(_InputIterator, _InputIterator, _Allocator = _Allocator())
  -> hive<__iter_value_type<_InputIterator>, _Allocator>;

#if _LIBCPP_STD_VER >= 23
template <ranges::input_range _Rp,
      class _Allocator = allocator<ranges::range_value_t<_Rp>>,
      class = enable_if_t<__is_allocator<_Allocator>::value>>
hive(from_range_t, _Rp&&, _Allocator = _Allocator())
  -> hive<ranges::range_value_t<_Rp>, _Allocator>;
#endif

template <class _Tp, class _Allocator, class _Pred>
typename hive<_Tp, _Allocator>::size_type erase_if(hive<_Tp, _Allocator>& __h, _Pred __pred) {
  typename hive<_Tp, _Allocator>::size_type __count = 0;
  auto __end = __h.end();
  for (auto __it = __h.begin(); __it != __end; ++__it) {
    if (__pred(*__it)) {
      auto __orig = ++__count;
      auto __last = __it;
      while (++__last != __end && __pred(*__last)) {
        ++__count;
      }
      if (__count != __orig) {
        __it = __h.erase(__it, __last);
      } else {
        __it = __h.erase(__it);
      }
      __end = __h.end();
      if (__it == __end) {
        break;
      }
    }
  }
  return __count;
}

template <class _Tp, class _Allocator, class _Up>
inline typename hive<_Tp, _Allocator>::size_type erase(hive<_Tp, _Allocator>& __h, const _Up& __value) {
  return std::erase_if(__h, [&](const _Up& __x) { return __x == __value; });
}

_LIBCPP_END_NAMESPACE_STD

_LIBCPP_BEGIN_NAMESPACE_STD
namespace pmr {
template <class _Tp>
using hive = std::hive<_Tp, polymorphic_allocator<_Tp>>;
} // namespace pmr
_LIBCPP_END_NAMESPACE_STD

_LIBCPP_POP_MACROS

#endif // _LIBCPP_STD_VER >= 20

#endif // _LIBCPP_HIVE
